#!/usr/bin/env bash
# shellcheck disable=SC2034,SC1090
#==============================================================================
# PostgreSQL & pgAdmin Container Manager
#==============================================================================

set -Eeuo pipefail
IFS=$'\n\t'

#------------------------------------------------------------------------------
# Constants
#------------------------------------------------------------------------------
readonly GREEN=$'\e[0;32m'
readonly RED=$'\e[0;31m'
readonly YELLOW=$'\e[0;33m'
readonly BLUE=$'\e[0;34m'
readonly BOLD=$'\e[1m'
readonly NC=$'\e[0m'

#------------------------------------------------------------------------------
# Logging helpers
#------------------------------------------------------------------------------
log() { # (level, msg)
  local clr pre
  case $1 in
    info)    clr=$BLUE  ; pre="> ";;
    success) clr=$GREEN ; pre="✓ ";;
    warn)    clr=$YELLOW; pre="! ";;
    error)   clr=$RED   ; pre="✗ ";;
    header)  clr=$BLUE  ; pre="== ";;
    section) clr=$YELLOW; pre="-- ";;
  esac
  shift
  printf "%b%s%b\n" "$clr" "$pre$*" "$NC"
}

require_cmd() { command -v "$1" &>/dev/null || { log error "Command '$1' not found"; exit 1; }; }

#------------------------------------------------------------------------------
# Compose helpers
#------------------------------------------------------------------------------
find_compose_file() { # (dir)
  local v; for v in docker-compose.yaml docker-compose.yml compose.yaml compose.yml; do
    [[ -f "$1/$v" ]] && { echo "$1/$v"; return; }
  done
}

docker_compose() { docker compose -f "$COMPOSE_FILE" "$@"; }

detect_conflict() { docker ps --filter "publish=$1" --format "{{.Names}}"; }

shutdown_conflict() { # (container)
  local cnt=$1 dir file
  dir=$(docker inspect "$cnt" -f '{{index .Config.Labels "com.docker.compose.project.working_dir"}}' 2>/dev/null || true)
  file="${dir:+$(find_compose_file "$dir" || true)}"
  if [[ -n $file ]]; then
    log info "Stopping $cnt via docker compose -f $file down"
    docker compose -f "$file" down
  else
    log info "Stopping $cnt via docker stop"
    docker stop "$cnt"
  fi
}

show_port_conflicts() {
  local port cnt dir file
  for port in "$PG_PORT" "$PGADMIN_PORT"; do
    if cnt=$(detect_conflict "$port"); [[ -n $cnt ]]; then
      log warn "Port $port is already used by container: $cnt"
      dir=$(docker inspect "$cnt" -f '{{index .Config.Labels "com.docker.compose.project.working_dir"}}' 2>/dev/null || true)
      file="${dir:+$(find_compose_file "$dir" || true)}"
      if [[ -n $file ]]; then
        log info "→ Stop it with: docker compose -f $file down"
      else
        log info "→ Stop it with: docker stop $cnt"
      fi
    fi
  done
  log info "Quick fix: pg fix"
  log info "Alternatively set different PG_PORT / PGADMIN_PORT env vars."
}

#------------------------------------------------------------------------------
# Usage
#------------------------------------------------------------------------------
usage() {
  printf "${BOLD}Usage:${NC} pg <command>\n\n"
  printf "Commands:\n"
  printf "  ${GREEN}start${NC}   Start PostgreSQL & pgAdmin containers\n"
  printf "  ${BLUE}status${NC}  Show status & connection info\n"
  printf "  ${YELLOW}stop${NC}    Stop containers\n"
  printf "  ${RED}clean${NC}   Stop containers & remove volumes\n"
  printf "  ${YELLOW}fix${NC}     Detect & fix port conflicts\n"
}

#------------------------------------------------------------------------------
# Connection info display
#------------------------------------------------------------------------------
show_connections() {
  log section "Connection Info"
  local lbl pad="%-8s"
  if docker_compose ps --services --filter status=running | grep -q postgres; then
    printf "${GREEN}✓ ${BOLD}${pad}${NC}: %s:%s  user=%s  db=%s\n" "PG" "$DB_HOST" "$PG_PORT" "$DB_USER" "$DB_NAME"
    printf "  ${pad}: jdbc:postgresql://%s:%s/%s\n" "JDBC" "$DB_HOST" "$PG_PORT" "$DB_NAME"
    printf "  ${pad}: PGPASSWORD=%s psql -h %s -p %s -U %s -d %s\n" "PSQL" "$DB_PASSWORD" "$DB_HOST" "$PG_PORT" "$DB_USER" "$DB_NAME"
  else
    log warn "PostgreSQL not running"
  fi
  if docker_compose ps --services --filter status=running | grep -q pgadmin; then
    printf "${GREEN}✓ ${BOLD}${pad}${NC}: %s\n" "pgAdmin" "$PGADMIN_URL"
  else
    log warn "pgAdmin not running"
  fi
}

#------------------------------------------------------------------------------
# Environment setup
#------------------------------------------------------------------------------
require_cmd docker
readonly SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$(find_compose_file "$SCRIPT_DIR")" || { log error "No compose file in $SCRIPT_DIR"; exit 1; }

readonly PG_PORT="${PG_PORT:-15432}"
readonly PGADMIN_PORT="${PGADMIN_PORT:-15433}"
readonly DB_HOST=localhost
readonly DB_USER=postgres
readonly DB_PASSWORD=password
readonly DB_NAME=postgres
readonly PGADMIN_URL="http://localhost:${PGADMIN_PORT}"

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------
cmd=${1-}
case $cmd in
  start)
    log header "Starting containers"
    if docker_compose up -d; then
      log success "Containers started"
      docker_compose ps
    else
      log error "Failed to start – port conflict detected"
      show_port_conflicts
      exit 1
    fi
    ;;
  stop)
    log header "Stopping containers"; docker_compose down ;;
  clean)
    log header "Cleaning containers & volumes"; docker_compose down -v ;;
  status)
    log header "Container Status"; docker_compose ps; show_connections ;;
  fix)
    log header "Resolving Port Conflicts"
    for p in "$PG_PORT" "$PGADMIN_PORT"; do
      if c=$(detect_conflict "$p"); [[ -n $c ]]; then shutdown_conflict "$c"; fi
    done ;;
  *) usage; exit 1 ;;
esac
